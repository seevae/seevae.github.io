{"posts":[{"title":"golang实现MCP Server","text":"本文主要展示如何通过golang编写mcp服务，以及如何将多个工具整合在一个mcp中，并且同时支持STDIO和SSE两种方式，不涉及过多的原理性概念性内容～ 什么是MCP？MCP（model context protocol）是由Anthropic（claude的母公司）推出的一套开放协议，协议旨在提供一种大模型与外部工具集成的标准方式。 简单形象的理解就是AI届的USB-C接口。 MCP带来的意义有了这个协议，理论上我们就能无限强大AI的能力，去根据自己的定制需求扩展AI。 打个比方，今天你想从北京海淀去天安门游玩，在这个过程中你还需要去吃一顿饭，还想去商场买一件衣服。按照现有的大模型能力，他只能基于已有的训练数据告诉你大致的路径，可能的商场和饭店有哪些，然后你根据他的推荐去完成自己目标。但是现在有了MCP，比如前段时间高德导航就发布了自己的MCP服务，此时你将该MCP接入自己的大模型，大模型就会自动发现高德导航这个工具，然后去调用高德导航工具，工具的背后对应的就是高德整个服务资源和应用能力，至此你的大模型就具有了高德导航的能力，他能够帮你精确的导航并规划好从海淀到天安门怎么走，会路过哪些饭店、商场。如果未来大众点评也开发了自己的MCP服务，那我们再将大众点评接入，大模型就能自动为我们匹配出来路过的这些饭店、商场哪一家的评分最高，最终直接帮助我们规划出来一条最佳的路径，既能从海淀到天安门，又能找到最便利，评价最高的食堂、商场。你看，MCP对于LLM来说就是如虎添翼，就像钢铁侠有了贾维斯。并且哪天这条路径修路了你也不用担心，因为MCP都是实时调用的，只要高德更新了这段路况，你的大模型就不会因为知识过旧给出你错误的方案。 总结下MCP带来的意义： 提供LLM集成外部工具的统一标准，降低了开发者的开发难度 实时数据更新，支持外部动态服务所以数据每次都是服务提供的最新的 自动发现工具，LLM可以同时集成很多工具，并且能够根据语义在不同的对话场景中选择合适的工具 我们如何编写一个MCP服务当前的MCP服务分为两种通信方式，一种是stdio，一种是基于SSE的HTTP通信方式（官方最新的通信方式已经可以不使用SSE了）。 stdio的方式是一种本地通信的方式，这种方式要求大模型和MCP服务必须在同一台计算机中。 基于SSE的HTTP通信方式可以使得MCP服务能够部署在远程，客户端通过HTTP协议去进行访问。 golang实现一个MCP服务为了简化需求，我们接下来实现一个两个数相加永远等于1的MCP服务。这个例子非常简单，但主要是为了梳理实现一个MCP服务都需要哪些步骤，看官姥爷以后做自己的MCP服务时候只需要把这个无厘头的逻辑封装的方法换成自己实际的业务方法就好了。 该例子会同时实现stdio和sse两种方式的MCP，方便大家直观的了解这两种方案。 话不多说先看代码，具体的逻辑会注释在代码中，最后会对整个流程进行总结概括 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package mainimport ( &quot;context&quot; &quot;errors&quot; &quot;flag&quot; &quot;fmt&quot; &quot;github.com/mark3labs/mcp-go/mcp&quot; &quot;github.com/mark3labs/mcp-go/server&quot;)const ( // 服务常量 serviceName = &quot;test_mcp_server&quot; serviceVersion = &quot;1.0.0&quot; // 工具常量 toolName = &quot;get_sum_num&quot; toolDescription = &quot;Calculate the value of two numbers&quot; paramNumA = &quot;numA&quot; paramNumADesc = &quot;The first addition (required)&quot; paramNumB = &quot;numB&quot; paramNumBDesc = &quot;The second addition (required)&quot;)func main() { // 定义命令行参数 mode := flag.String(&quot;mode&quot;, &quot;stdio&quot;, &quot;服务模式: stdio, sse, 或 both&quot;) port := flag.String(&quot;port&quot;, &quot;3001&quot;, &quot;HTTP服务器端口 (仅在sse模式下使用)&quot;) flag.Parse() // 创建MCP服务器 s := server.NewMCPServer(serviceName, serviceVersion) // 添加工具 tool := mcp.NewTool(toolName, mcp.WithDescription(toolDescription), mcp.WithNumber(paramNumA, mcp.Required(), mcp.Description(paramNumADesc), ), mcp.WithNumber(paramNumB, mcp.Required(), mcp.Description(paramNumBDesc), ), ) // 将工具和工具处理逻辑加入MCP服务器 s.AddTool(tool, getValueOfTwoNumbers) // 根据模式启动相应的服务器 if *mode == &quot;sse&quot; { // 仅启动HTTP服务器 fmt.Printf(&quot;正在启动HTTP服务器，端口: %s...\\n&quot;, *port) sseServer := server.NewSSEServer(s) err := sseServer.Start(&quot;:&quot; + *port) if err != nil { fmt.Printf(&quot;sse服务Start错误: %v\\n&quot;, err) } } else { // 仅启动stdio服务器 if err := server.ServeStdio(s); err != nil { fmt.Printf(&quot;Stdio服务器错误: %v\\n&quot;, err) } }}// 该方法的关键就在于自己业务逻辑处理后将处理后的结果交给mcp，也就是方法的最后一行代码func getValueOfTwoNumbers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) { paramA, ok := request.Params.Arguments[paramNumA].(float64) if !ok { return nil, errors.New(&quot;get paramA fail&quot;) } paramB, ok := request.Params.Arguments[paramNumB].(float64) if !ok { return nil, errors.New(&quot;get paramB fail&quot;) } response, err := calculateTwoNumbers(paramA, paramB) if err != nil { return nil, err } return mcp.NewToolResultText(response), nil}// 这个方法没什么逻辑就是不管两数多少都返回1。在现实业务中具体实现时可以根据业务场景替换方法，比如你的业务是请求后段某个接口获取一些数据，那么就可以在这里加一个http客户端去请求服务端拿数据func calculateTwoNumbers(numA float64, numB float64) (string, error) { return &quot;1&quot;, nil} 整个逻辑可以分为以下几步： 创建mcp服务器 添加工具 将工具和工具逻辑处理器添加进MCP服务器 根据用户的选择启动不同方式的MCP服务（基于stdio还是sse的） 其中1，2，4步其实都是固定的套路，作为开发者我们只需要关注工具的创建和具体工具逻辑的实现，也就是代码中的getValueOfTwoNumbers方法和calculateTwoNumbers方法。 calculateTwoNumbers方法就是我们具体的业务逻辑，getValueOfTwoNumbers相当于一个service层用来过渡，当然你也可以把这两个方法融为一个，看个人爱好以及代码分层习惯了。 测试MCP服务MCP 交互是典型的CS架构，测试MCP服务我们需要有一个客户端。在实际的使用过程中调用方一般是HOST+Client的组合，HOST可以理解为LLM启动连接的应用程序，比如Cursor，Cline等等。Client是用来在HOST应用程序内维护与MCP server之间1:1的连接。 在这里我们简化了client的概念，不引入LLM，直接使用MCP官方提供的MCP检查器。这个检查器可以直接调用MCP服务，列出MCP服务中的工具。如果在这里MCP服务能够正常使用，那么之后不管使用什么大模型的客户端只需要把你的MCP服务添加进去就好了。 mcp server服务启动项目打包为二进制服务，根据不同参数选择不同的启动方式，如果是stdio的方式则在客户端配置server的启动，如果是sse的方式自己本地把服务跑起来就ok 运行MCP Inspector执行命令 npx @modelcontextprotocol/inspector（需要安装node相关环境） 配置STDIO的连接方式 从图中可以看出来，mcp client已经能够识别出来我们的mcp server了。stdio的调用方式成功 配置SSE的连接方法 同样的，如果使用Cherry Studio也能够配置成功 至此，就成功的完成了一个MCP Server服务！能够集成大模型完成定制化的需求了（你可以给朋友说你有个非常笨的大模型，算什么算数都是1，hh～） 实现一个MCP服务包含多个工具上述的mcp中只有一个计算工具，那么我们如何在一个mcp中实现多个工具的集成？达到在MCP Inspector中能够列出多个工具呢？总不能做一个功能就写一个mcp服务占用一个端口吧。接下来将继续实现这个需求。 //todo 作者摸鱼去了","link":"/2025/04/17/golang_mcp/"},{"title":"JVM内存分配与对象创建","text":"本文主要介绍JVM运行时内存划分，然后简述Java对象的创建过程与Java对象的内存模型以及如何访问一个Java对象，最后结合实际案例给出一个堆溢出的原因排查过程 JVM运行时数据区域划分与内存溢出异常JVM运行时数据区可以从是否为线程私有分为两大部分，其中程序计数器、Java虚拟机栈、本地方法栈为线程私有；堆、方法区为线程共有。他们共同组成了JVM运行时内存，具体如图所示：接下来逐一介绍： 程序计数器可以看作是当前线程所执行的字节码的行号指示器。他记录了当前线程执行到了字节码的哪个位置、记录线程上下文切换的位置、程序中控制语句执行的位置、异常处理、线程恢复等等信息。这一片区域是《Java虚拟机规范》中规定不会发生任何内存溢出的区域 Java虚拟机栈这个就是我们经常听到的JVM分为“堆”和“栈”的其中那个栈。Java虚拟机栈用来描述Java方法执行的线程内存模型。每当一个方法被调用时，都会在虚拟机栈中为这个方法创建一个栈帧，栈帧中会记录临时变量、对象引用、方法出口等信息。等方法执行完毕后，栈帧就会被销毁。该区域大小可以选择是否可以动态扩容，如果不能扩容，那么如果碰到无限递归的方法，就可能发生StackOverflowError异常；如果能够动态扩容，那么无限递归的方法会耗尽JVM内存，发生OutOfMemoryError异常 本地方法栈本地方法栈和Java虚拟机栈类似，不同的是Java虚拟机栈记录的Java方法的调用情况，本地方法栈记录的是本地方法调用时的情况 Java堆堆是JVM虚拟机管理的内存中的最大的一块。也是所有线程共享的区域。此内存区域的目的就是存放实例对象。几乎所有的对象实例和数组都存储在这里（由于即时编译的发展以及逃逸分析技术的发展导致有些对象实例也不一定在堆上，所以使用了几乎的描述）。这里需要注意会有人把堆又分为老年代、新生代等区域，但是这种区域的划分其实不是JVM规定的划分方式，而是有些虚拟机为了从对象回收的角度来更好的区分堆内存而进行的划分。如果堆的空间耗尽，会发生OOM异常 方法区方法区中存着已经加载的类信息、常量、静态变量等信息。之前还被称呼为“永久代”，但同样的这也不是JVM的规范，而是在Java8之前hotspot使用永久代的方式实现了方法区，方便JVM管理内存。到Java8之后，已经不使用这种方式，方法区使用了元空间的方式去实现了，内存可以直接使用本地内存进行分配。但是方法区在逻辑概念上依然属于JVM运行时数据区的一部分。如果方法区的内存耗尽，会发生OOM异常。 运行时常量池运行时常量池是方法区中的一部分。当Class被加载运行的时候，其中Class常量池中字符串、符号引用等内容就会被加载到运行时常量池中。还会把符号引用翻译出来的直接引用也存储在运行时常量池中。不同于Class文件的常量池。运行时常量池可以在程序动态运行的过程中加入常量，比如String.intern()的方法触发的字符串入池。常量池的空间耗尽会去找方法区继续申请空间，最终没有可申请的空间了也会出现OOM 直接内存NIO会使用NATIVE函数库直接分配堆外内存，然后通过一个存储在堆中的对象作为这块内存的引用进行操作，这样在一些场景中能显著提升系统性能。这篇区域不属于JVM运行时数据区，但是由于他的工作方式很容易造成开发者对于JVM内存分配的错误估计，造成本机内存耗尽，最终发生OOM异常。 Java对象的创建、内存分配和访问介绍完了内存空间的划分，那么一个对象又是怎么被创建出来如何被访问呢，我们从流程上先来看下这个过程。注意：此后的所有内容都是基于hotspots虚拟机的实现来讲的 Java对象的创建过程当执行了一个new命令背后的执行逻辑大致可以分为如下几步： 根据当前引用到字符串常量池中查看是否有相同引用并检查对应引用代表的类是否已经加载、解析和初始化，如果没有就进行类加载过程 类加载检查通过后，会去堆上为对象分配内存空间。 空间分配完成后进行空间的零值的初始化（不包括对象头），确保对象的实例字段在Java代码中可以不赋值就直接使用，使程序能够访问到这些字段的数据类型对应的零值 进行对象头的初始化，是否启用偏向锁、对象是哪个类的实例、如何找到类的元数据信息、对象哈希码等等 执行到第四步JVM的角度看对象的创建就完成了。但是此时从Java程序视角来看，对象的创建才刚刚开始 调用构造函数，Class文件中的()方法，开始初始化实例中具体内容的值至此，一个Java对象就被创建出来了 Java对象的内存布局那么一个Java对象又是由哪些部分组成的呢？ 对象头也称为MarkWord，其中存储了对象的元数据信息，包括对象的hash码、线程持有的锁、锁偏向线程、GC分代年龄等等。还有一部分是类型指针，即对象指向他的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。需要注意如果对象是一个数组，那么对象头中还会有字段去记录数据的长度 实例数据部分这部分是真正存储对象数据的部分，即我们在代码中定义的各种字段，也包括从父类继承下来的。变量记录的顺序依赖于虚拟机策略的设定。 对齐填充这部分没有实际的意义，仅仅起着占位的作用。Hotspot虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐的话，在这里就会被填充对齐内存大小 Java对象的访问创建好对象自然就是为了访问，那么在JVM中是如何找到一个具体的对象呢。前面说到了Java虚拟机栈上会存对象的引用，找到具体的对象就是利用这个引用。常见的方式有两种，使用句柄访问和直接访问两种 句柄访问句柄访问的方式会在堆中维护一个句柄池，池子中存放了对象实例地址。栈中引用对象的内容就是句柄在句柄池中的位置。每当需要找一个对象的时候，会从栈中找到句柄位置，然后根据句柄位置找到实例。优点：这种方式的优点在于引用会十分的稳定，即时垃圾收集器挪动了对象实例的位置，但是引用指向的句柄地址是不会变的，实例位置变后句柄更新就好不需要改变引用。 直接访问这种方式引用中会直接存储对象实例的地址，只需要根据引用中记录的堆中地址去访问对象实例就好。优点：由于没有了句柄池这个中间步骤，访问的速度自然会快很多。 OutOfMemoryException排查场景制造这里写一段死循环创建对象的代码，最终大量的被引用对象会导致堆溢出。工程环境为普通的spring mvc架构的项目 代码： 123456789101112131415161718192021222324//controller层代码@RestController@RequestMapping(&quot;/api/v1/oom&quot;)@Slf4jpublic class OOMTestController { @Resource IComponentBannedRuleService componentBannedRuleService; @GetMapping(&quot;/heap&quot;) public String triggerHeapOOM() { componentBannedRuleService.testOOM(); return &quot;- -&quot;; }}//service层代码@Overridepublic void testOOM() { log.info(&quot;开始无限创建对象&quot;); List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); while (true) { list.add(new OOMObject()); }} 服务jvm参数：-XX:+HeapDumpOnOutOfMemoryError 堆溢出的时候打印堆快照文件-XX:HeapDumpPath=/export/Logs/jvm/ 放置堆快照文件的目录 启动服务调用接口后不久出现OOM异常:此时可以看到目标目录下出现了堆快照文件: 使用Jprofiler排查堆溢出 将dump文件导入应用，可以看到所有的对象集合，能够发现OOMObject对象占用了97%的内存空间 双击对象或者选择引用选项，选择传入引用，这时候就能够看到对象的引用链，点击详细更多还能看到具体的代码追踪，就可以找到是对应代码中的哪一行创建的这个对象了上述例子是个非常简单的OOM溢出排查，实际业务中还要结合代码逻辑仔细分析哪些对象的内存比例异常，从而解决问题","link":"/2025/04/21/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"AI","slug":"AI","link":"/tags/AI/"}],"categories":[],"pages":[]}