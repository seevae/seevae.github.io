{"posts":[{"title":"golang实现MCP Server","text":"本文主要展示如何通过golang编写mcp服务，以及如何将多个工具整合在一个mcp中，并且同时支持STDIO和SSE两种方式，不涉及过多的原理性概念性内容～ 什么是MCP？MCP（model context protocol）是由Anthropic（claude的母公司）推出的一套开放协议，协议旨在提供一种大模型与外部工具集成的标准方式。 简单形象的理解就是AI届的USB-C接口。 MCP带来的意义有了这个协议，理论上我们就能无限强大AI的能力，去根据自己的定制需求扩展AI。 打个比方，今天你想从北京海淀去天安门游玩，在这个过程中你还需要去吃一顿饭，还想去商场买一件衣服。按照现有的大模型能力，他只能基于已有的训练数据告诉你大致的路径，可能的商场和饭店有哪些，然后你根据他的推荐去完成自己目标。但是现在有了MCP，比如前段时间高德导航就发布了自己的MCP服务，此时你将该MCP接入自己的大模型，大模型就会自动发现高德导航这个工具，然后去调用高德导航工具，工具的背后对应的就是高德整个服务资源和应用能力，至此你的大模型就具有了高德导航的能力，他能够帮你精确的导航并规划好从海淀到天安门怎么走，会路过哪些饭店、商场。如果未来大众点评也开发了自己的MCP服务，那我们再将大众点评接入，大模型就能自动为我们匹配出来路过的这些饭店、商场哪一家的评分最高，最终直接帮助我们规划出来一条最佳的路径，既能从海淀到天安门，又能找到最便利，评价最高的食堂、商场。你看，MCP对于LLM来说就是如虎添翼，就像钢铁侠有了贾维斯。并且哪天这条路径修路了你也不用担心，因为MCP都是实时调用的，只要高德更新了这段路况，你的大模型就不会因为知识过旧给出你错误的方案。 总结下MCP带来的意义： 提供LLM集成外部工具的统一标准，降低了开发者的开发难度 实时数据更新，支持外部动态服务所以数据每次都是服务提供的最新的 自动发现工具，LLM可以同时集成很多工具，并且能够根据语义在不同的对话场景中选择合适的工具 我们如何编写一个MCP服务当前的MCP服务分为两种通信方式，一种是stdio，一种是基于SSE的HTTP通信方式（官方最新的通信方式已经可以不使用SSE了）。 stdio的方式是一种本地通信的方式，这种方式要求大模型和MCP服务必须在同一台计算机中。 基于SSE的HTTP通信方式可以使得MCP服务能够部署在远程，客户端通过HTTP协议去进行访问。 golang实现一个MCP服务为了简化需求，我们接下来实现一个两个数相加永远等于1的MCP服务。这个例子非常简单，但主要是为了梳理实现一个MCP服务都需要哪些步骤，看官姥爷以后做自己的MCP服务时候只需要把这个无厘头的逻辑封装的方法换成自己实际的业务方法就好了。 该例子会同时实现stdio和sse两种方式的MCP，方便大家直观的了解这两种方案。 话不多说先看代码，具体的逻辑会注释在代码中，最后会对整个流程进行总结概括 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package mainimport ( &quot;context&quot; &quot;errors&quot; &quot;flag&quot; &quot;fmt&quot; &quot;github.com/mark3labs/mcp-go/mcp&quot; &quot;github.com/mark3labs/mcp-go/server&quot;)const ( // 服务常量 serviceName = &quot;test_mcp_server&quot; serviceVersion = &quot;1.0.0&quot; // 工具常量 toolName = &quot;get_sum_num&quot; toolDescription = &quot;Calculate the value of two numbers&quot; paramNumA = &quot;numA&quot; paramNumADesc = &quot;The first addition (required)&quot; paramNumB = &quot;numB&quot; paramNumBDesc = &quot;The second addition (required)&quot;)func main() { // 定义命令行参数 mode := flag.String(&quot;mode&quot;, &quot;stdio&quot;, &quot;服务模式: stdio, sse, 或 both&quot;) port := flag.String(&quot;port&quot;, &quot;3001&quot;, &quot;HTTP服务器端口 (仅在sse模式下使用)&quot;) flag.Parse() // 创建MCP服务器 s := server.NewMCPServer(serviceName, serviceVersion) // 添加工具 tool := mcp.NewTool(toolName, mcp.WithDescription(toolDescription), mcp.WithNumber(paramNumA, mcp.Required(), mcp.Description(paramNumADesc), ), mcp.WithNumber(paramNumB, mcp.Required(), mcp.Description(paramNumBDesc), ), ) // 将工具和工具处理逻辑加入MCP服务器 s.AddTool(tool, getValueOfTwoNumbers) // 根据模式启动相应的服务器 if *mode == &quot;sse&quot; { // 仅启动HTTP服务器 fmt.Printf(&quot;正在启动HTTP服务器，端口: %s...\\n&quot;, *port) sseServer := server.NewSSEServer(s) err := sseServer.Start(&quot;:&quot; + *port) if err != nil { fmt.Printf(&quot;sse服务Start错误: %v\\n&quot;, err) } } else { // 仅启动stdio服务器 if err := server.ServeStdio(s); err != nil { fmt.Printf(&quot;Stdio服务器错误: %v\\n&quot;, err) } }}// 该方法的关键就在于自己业务逻辑处理后将处理后的结果交给mcp，也就是方法的最后一行代码func getValueOfTwoNumbers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) { paramA, ok := request.Params.Arguments[paramNumA].(float64) if !ok { return nil, errors.New(&quot;get paramA fail&quot;) } paramB, ok := request.Params.Arguments[paramNumB].(float64) if !ok { return nil, errors.New(&quot;get paramB fail&quot;) } response, err := calculateTwoNumbers(paramA, paramB) if err != nil { return nil, err } return mcp.NewToolResultText(response), nil}// 这个方法没什么逻辑就是不管两数多少都返回1。在现实业务中具体实现时可以根据业务场景替换方法，比如你的业务是请求后段某个接口获取一些数据，那么就可以在这里加一个http客户端去请求服务端拿数据func calculateTwoNumbers(numA float64, numB float64) (string, error) { return &quot;1&quot;, nil} 整个逻辑可以分为以下几步： 创建mcp服务器 添加工具 将工具和工具逻辑处理器添加进MCP服务器 根据用户的选择启动不同方式的MCP服务（基于stdio还是sse的） 其中1，2，4步其实都是固定的套路，作为开发者我们只需要关注工具的创建和具体工具逻辑的实现，也就是代码中的getValueOfTwoNumbers方法和calculateTwoNumbers方法。 calculateTwoNumbers方法就是我们具体的业务逻辑，getValueOfTwoNumbers相当于一个service层用来过渡，当然你也可以把这两个方法融为一个，看个人爱好以及代码分层习惯了。 测试MCP服务MCP 交互是典型的CS架构，测试MCP服务我们需要有一个客户端。在实际的使用过程中调用方一般是HOST+Client的组合，HOST可以理解为LLM启动连接的应用程序，比如Cursor，Cline等等。Client是用来在HOST应用程序内维护与MCP server之间1:1的连接。 在这里我们简化了client的概念，不引入LLM，直接使用MCP官方提供的MCP检查器。这个检查器可以直接调用MCP服务，列出MCP服务中的工具。如果在这里MCP服务能够正常使用，那么之后不管使用什么大模型的客户端只需要把你的MCP服务添加进去就好了。 mcp server服务启动项目打包为二进制服务，根据不同参数选择不同的启动方式，如果是stdio的方式则在客户端配置server的启动，如果是sse的方式自己本地把服务跑起来就ok 运行MCP Inspector执行命令 npx @modelcontextprotocol/inspector（需要安装node相关环境） 配置STDIO的连接方式 从图中可以看出来，mcp client已经能够识别出来我们的mcp server了。stdio的调用方式成功 配置SSE的连接方法 同样的，如果使用Cherry Studio也能够配置成功 至此，就成功的完成了一个MCP Server服务！能够集成大模型完成定制化的需求了（你可以给朋友说你有个非常笨的大模型，算什么算数都是1，hh～） 实现一个MCP服务包含多个工具上述的mcp中只有一个计算工具，那么我们如何在一个mcp中实现多个工具的集成？达到在MCP Inspector中能够列出多个工具呢？总不能做一个功能就写一个mcp服务占用一个端口吧。接下来将继续实现这个需求。 SSE方式的MCP通信原理在进行项目改造之前需要先大致了解一下SSE的通信原理，只有知道了客户端是怎么和服务端进行通信的，才能够根据通信方式开发出理想的代码，这里只大概讲述一下SSE的原理SSE的通信方式是一种长链接的单方向通信方式，客户端和服务端会建立长链接，但是不同于websocket，这个长链接上只能够从服务端推送消息到客户端，不能够双向通信。具体的流程如下： 客户端携带一个sessionId向服务端发送一个表示此次回话的请求，试图建立通信通道 客户端收到后开启一个sse长链接，并返回长链接通信的地址称为端点 之后的过程为，客户端向端点发送请求（比如依次新的询问），服务端通过sse长链接进行响应总结来说，sse通信会建立一个长链接，客户端每次携带一个表示某一次对话的sessionId向服务端端点发送请求获取响应结果，最终服务端将响应结果通过长链接返回客户端。 实现通过以上思路，预设计服务： 能够同时注册并启动多个sse服务，每个sse服务提供一个端点（一个可以给客户端访问的url） 整个服务对外暴露一个端口，通过不同的端点区分不同的sse服务 服务启动后将不同的端点注册至客户端作为一个个独立的mcp服务 代码实现//todo","link":"/2025/04/17/golang_mcp/"},{"title":"JVM内存分配与对象创建","text":"本文主要介绍JVM运行时内存划分，然后简述Java对象的创建过程与Java对象的内存模型以及如何访问一个Java对象，最后结合实际案例给出一个堆溢出的原因排查过程 JVM运行时数据区域划分与内存溢出异常JVM运行时数据区可以从是否为线程私有分为两大部分，其中程序计数器、Java虚拟机栈、本地方法栈为线程私有；堆、方法区为线程共有。他们共同组成了JVM运行时内存，具体如图所示：接下来逐一介绍： 程序计数器可以看作是当前线程所执行的字节码的行号指示器。他记录了当前线程执行到了字节码的哪个位置、记录线程上下文切换的位置、程序中控制语句执行的位置、异常处理、线程恢复等等信息。这一片区域是《Java虚拟机规范》中规定不会发生任何内存溢出的区域 Java虚拟机栈这个就是我们经常听到的JVM分为“堆”和“栈”的其中那个栈。Java虚拟机栈用来描述Java方法执行的线程内存模型。每当一个方法被调用时，都会在虚拟机栈中为这个方法创建一个栈帧，栈帧中会记录临时变量、对象引用、方法出口等信息。等方法执行完毕后，栈帧就会被销毁。该区域大小可以选择是否可以动态扩容，如果不能扩容，那么如果碰到无限递归的方法，就可能发生StackOverflowError异常；如果能够动态扩容，那么无限递归的方法会耗尽JVM内存，发生OutOfMemoryError异常 本地方法栈本地方法栈和Java虚拟机栈类似，不同的是Java虚拟机栈记录的Java方法的调用情况，本地方法栈记录的是本地方法调用时的情况 Java堆堆是JVM虚拟机管理的内存中的最大的一块。也是所有线程共享的区域。此内存区域的目的就是存放实例对象。几乎所有的对象实例和数组都存储在这里（由于即时编译的发展以及逃逸分析技术的发展导致有些对象实例也不一定在堆上，所以使用了几乎的描述）。这里需要注意会有人把堆又分为老年代、新生代等区域，但是这种区域的划分其实不是JVM规定的划分方式，而是有些虚拟机为了从对象回收的角度来更好的区分堆内存而进行的划分。如果堆的空间耗尽，会发生OOM异常 方法区方法区中存着已经加载的类信息、常量、静态变量等信息。之前还被称呼为“永久代”，但同样的这也不是JVM的规范，而是在Java8之前hotspot使用永久代的方式实现了方法区，方便JVM管理内存。到Java8之后，已经不使用这种方式，方法区使用了元空间的方式去实现了，内存可以直接使用本地内存进行分配。但是方法区在逻辑概念上依然属于JVM运行时数据区的一部分。如果方法区的内存耗尽，会发生OOM异常。 运行时常量池运行时常量池是方法区中的一部分。当Class被加载运行的时候，其中Class常量池中字符串、符号引用等内容就会被加载到运行时常量池中。还会把符号引用翻译出来的直接引用也存储在运行时常量池中。不同于Class文件的常量池。运行时常量池可以在程序动态运行的过程中加入常量，比如String.intern()的方法触发的字符串入池。常量池的空间耗尽会去找方法区继续申请空间，最终没有可申请的空间了也会出现OOM 直接内存NIO会使用NATIVE函数库直接分配堆外内存，然后通过一个存储在堆中的对象作为这块内存的引用进行操作，这样在一些场景中能显著提升系统性能。这篇区域不属于JVM运行时数据区，但是由于他的工作方式很容易造成开发者对于JVM内存分配的错误估计，造成本机内存耗尽，最终发生OOM异常。 Java对象的创建、内存分配和访问介绍完了内存空间的划分，那么一个对象又是怎么被创建出来如何被访问呢，我们从流程上先来看下这个过程。注意：此后的所有内容都是基于hotspots虚拟机的实现来讲的 Java对象的创建过程当执行了一个new命令背后的执行逻辑大致可以分为如下几步： 根据当前引用到字符串常量池中查看是否有相同引用并检查对应引用代表的类是否已经加载、解析和初始化，如果没有就进行类加载过程 类加载检查通过后，会去堆上为对象分配内存空间。 空间分配完成后进行空间的零值的初始化（不包括对象头），确保对象的实例字段在Java代码中可以不赋值就直接使用，使程序能够访问到这些字段的数据类型对应的零值 进行对象头的初始化，是否启用偏向锁、对象是哪个类的实例、如何找到类的元数据信息、对象哈希码等等 执行到第四步JVM的角度看对象的创建就完成了。但是此时从Java程序视角来看，对象的创建才刚刚开始 调用构造函数，Class文件中的()方法，开始初始化实例中具体内容的值至此，一个Java对象就被创建出来了 Java对象的内存布局那么一个Java对象又是由哪些部分组成的呢？ 对象头也称为MarkWord，其中存储了对象的元数据信息，包括对象的hash码、线程持有的锁、锁偏向线程、GC分代年龄等等。还有一部分是类型指针，即对象指向他的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。需要注意如果对象是一个数组，那么对象头中还会有字段去记录数据的长度 实例数据部分这部分是真正存储对象数据的部分，即我们在代码中定义的各种字段，也包括从父类继承下来的。变量记录的顺序依赖于虚拟机策略的设定。 对齐填充这部分没有实际的意义，仅仅起着占位的作用。Hotspot虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐的话，在这里就会被填充对齐内存大小 Java对象的访问创建好对象自然就是为了访问，那么在JVM中是如何找到一个具体的对象呢。前面说到了Java虚拟机栈上会存对象的引用，找到具体的对象就是利用这个引用。常见的方式有两种，使用句柄访问和直接访问两种 句柄访问句柄访问的方式会在堆中维护一个句柄池，池子中存放了对象实例地址。栈中引用对象的内容就是句柄在句柄池中的位置。每当需要找一个对象的时候，会从栈中找到句柄位置，然后根据句柄位置找到实例。优点：这种方式的优点在于引用会十分的稳定，即时垃圾收集器挪动了对象实例的位置，但是引用指向的句柄地址是不会变的，实例位置变后句柄更新就好不需要改变引用。 直接访问这种方式引用中会直接存储对象实例的地址，只需要根据引用中记录的堆中地址去访问对象实例就好。优点：由于没有了句柄池这个中间步骤，访问的速度自然会快很多。 OutOfMemoryException排查场景制造这里写一段死循环创建对象的代码，最终大量的被引用对象会导致堆溢出。工程环境为普通的spring mvc架构的项目 代码： 123456789101112131415161718192021222324//controller层代码@RestController@RequestMapping(&quot;/api/v1/oom&quot;)@Slf4jpublic class OOMTestController { @Resource IComponentBannedRuleService componentBannedRuleService; @GetMapping(&quot;/heap&quot;) public String triggerHeapOOM() { componentBannedRuleService.testOOM(); return &quot;- -&quot;; }}//service层代码@Overridepublic void testOOM() { log.info(&quot;开始无限创建对象&quot;); List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); while (true) { list.add(new OOMObject()); }} 服务jvm参数：-XX:+HeapDumpOnOutOfMemoryError 堆溢出的时候打印堆快照文件-XX:HeapDumpPath=/export/Logs/jvm/ 放置堆快照文件的目录 启动服务调用接口后不久出现OOM异常:此时可以看到目标目录下出现了堆快照文件: 使用Jprofiler排查堆溢出 将dump文件导入应用，可以看到所有的对象集合，能够发现OOMObject对象占用了97%的内存空间 双击对象或者选择引用选项，选择传入引用，这时候就能够看到对象的引用链，点击详细更多还能看到具体的代码追踪，就可以找到是对应代码中的哪一行创建的这个对象了上述例子是个非常简单的OOM溢出排查，实际业务中还要结合代码逻辑仔细分析哪些对象的内存比例异常，从而解决问题","link":"/2025/04/21/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM/"},{"title":"垃圾收集与对象内存分配策略.md","text":"本文讲述JVM垃圾回收过程中的一些内容，包括哪些内存应该被回收、何时回收、如何回收以及对象在内存中的分配策略 哪些内存需要回收？当对象不再存活，而是“死去”状态的时候，JVM就应该将对象所占用的内存空间进行回收。所以在判断哪些内存应该回收的时候，应该首先判断哪些对象“已死”，而对象死去的特征就是再也没有任何引用指向该对象。 那么如何判断对象是否还存在引用关系呢。常见的策略包括计数器法、可达性分析法，接下来着重说明这两种策略 对象已死的判断方法计数器法该方法是给每一个对象设定一个计数器，每当有引用指向这个对象，计数器就+1，当计数器的值为0的时候，就代表没有引用指向该对象了，此时就可以进行对象的回收了。但是该方法存在着无法解决循环引用的问题，所以不常用。循环引用造成引用计数器无法归零示意图A类中的属性引用指向B类，B类中的属性引用指向A类。此时即使A、B都没有任何的外部引用，但是引用计数器也不会归零，因为存在着属性的相互引用。计数器方式很难解决这样的循环引用对象，所以在一般的对象生命存活判断中不使用该方式。 可达性分析可达性分析法是指从一系列GC ROOT出发，判断能否到达对象内存，中间走过的路径称作引用链（Reference Chain），如果某个对象到GC ROOT没有引用链相连，或者用图论的话术来说是不可达的则认为对象已死。谁可以作为GC ROOT？ 在Java虚拟机栈（本地变量表）中引用的变量，比如一些函数调用时候用到的局部变量、临时变量、参数等 方法区中常量引用的对象，比如字符串常量池里面的引用 所有被同步锁持有的对象通过以上两种策略判断出来的已死对象都是JVM垃圾收集的目标。 已死对象的最后一次机会被判断“已死”的对象其实也不是绝对的就死定了。这时候他们仍处于一个缓刑的状态，一个对象真的被清除要经过两次标记的过程。当通过可达性分析发现一个对象已经没有引用链了，此时会将这个对象进行第一次的标记，随后会进行一次筛选，查看这些对象是否有必要执行finalize()方法。如果对象没有复写finalize()方法或者该方法已经被调用过，那么虚拟机将认为这个对象是没必要执行该方法的。如果这个对象有必要执行finalize方法，则会分配一个最低优先级的线程去执行该方法，在执行该方法的过程中，可以给对象重新建立引用关系，这个时候对象就能够“起死回生”了。 方法区的回收方法区的回收包括废弃的常量回收和不在使用的类型的回收。常量的回收和Java堆中的对象回收比较类似，当发现常量池中的字符串或引用没有在被使用的时候，就会回收。比如一个字符串“abc”，当系统中在没有一个字符串对象的值是“abc”，且虚拟机中也没有其他地方引用这个字面量，这个时候如果发生了内存回收，并且垃圾收集器认为有必要清理方法区，此时就会把该常量清除出去。类的回收相对就要麻烦一些，需要满足如下条件： 该类的所有实例都被回收了 加载该类的类加载器被回收了 类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 引用的分类Java中的引用分为强引用，软引用，弱引用，虚引用。这些引用的强度依次递减。 强引用：最传统的引用定义，如 Object ob = new Object()，指在程序中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会收掉被引用的对象。 软引用：用来描述一些还有用，但非必须的对象。此类引用在系统将要发生内存溢出的时候，会被列入回收范围之中进行第二次回收，如果这次回收还没有释放足够的内存，就会抛出OOM 弱引用：也是用来描述非必需的对象，但是强度更弱一些，被弱引用关联的对象只能生存到下一轮垃圾收集 虚引用：也叫做幽灵引用，他对于一个对象来说的唯一目的就是在对象被收回的时候能够接受到一个系统通知 垃圾收集算法上面讲述了哪些对象应该被收回以及判定对象已死的方法，那么具体怎么回收呢，接下来将介绍几种典型的垃圾收集算法。 分代收集理论现在所有的垃圾收集器都基于“分代理论”来进行设计，所谓理论其实就是一套经验规范。分代理论有三条，分别如下： 弱分代假说：绝大多数对象都是朝生夕死的 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡 跨代引用假说：跨代引用相对于同代引用来说仅占极少数基于上述假说促使垃圾收集器依据对象年龄将Java堆划分为新生代或老年代。也就是因为有区域的划分，因此才有了“Minor GC”、“Major GC”或者“Full GC”这样的回收类型的划分。而针对不同的区域中的对象特点，又随之出现了不同的垃圾收集算法。 标记-清除算法过程：首先进行对象的标记，找对堆中需要清理的对象进行标记，然后将标记的对象进行清理。这种方式的缺点在于如果对象十分的多，那么标记本身的效率就不会很高。其次，标记的对象被删除后很可能会出现内存碎片的现象，导致下次有大对象分配时找不到空间从而又触发垃圾收集。 标记-复制算法过程：又称为半区复制，他的思想是将内存分为两部分，一部分空闲，一部分分配对象，当触发垃圾收集的时候会对对象进行标记，将存活的对象复制到空闲半区，然后清理掉被标记对象。优势：相比于标记清除算法，复制算法的优势在于新对象空间分配的时候，他只要移动空间指针给对象分配内存就好了，不需要考虑内存碎片的问题。并且标记的时候可以根据对象的存活规律来选择是标记存活的还是标记未存活的，这样标记效率也会有所提高。缺点：这种方式的缺点在于会有一半的空间空闲，导致整体的内存使用率变低使用：目前主流的虚拟机都采用这个垃圾收集算法。IBM公司曾对新生代对象的“朝生夕死”特点进行过量化计算，最终发现大约98%的对象都熬不过第一轮收集。因此并不需要按照1:1的比例来划分新生代的内存空间。后来便有人提出了更优化的半区复制分代策略。将新生代分为一个大的Eden区域和两个小的Survivor区域，对象的分配都在Eden+一个Survivor上进行，当发生垃圾收集时候就把存活对象复制到另一个空闲的Survivor上，然后清理掉Eden区域和另一个Survivor区域。老年代的分配担保机制：Eden和Survivor的大小比例通常为8:1，也就是占用整个新生代的90%，留10%作为复制算法的可用空间。那么一旦留用的空闲空间不足以分配新的对象，这个时候就会触发堆的分配担保机制，此时创建的大对象会直接分配到老年代中。 标记-整理算法过程：将对象进行标记，然后将存活的对象移动到内存中的一片区域后清理掉除过这个区域外的垃圾对象。使用：这个算法主要是针对老年代设计出来的，所以主要使用的区域是老年代。与上述的算法不同，这个算法是基于“移动”操作的。移动对象的利弊：由于老年代中的对象基本都是存活的，需要进行垃圾收集的比较少，所以标记完成怎么处理大量存活的对象才是问题的关键。如果采用复制算法那么复制的成本就太高了，而且需要准备的空闲空间也太大了，所以不能采用复制原理。而如果选择不移动对象，只是清除掉未被标记的对象这样就会造成内存碎片化，一旦碎片程度加重无法在进行对象的分配，此时就需要调用系统内核进行内存的重新整理与分配，这个代价就比较高了，所以最终选择了对象的移动整理。这种做法虽然也会造成“stop the world”的发生，但是相比较于内存的重新分配，引用的重新创建，移动的成本相对还是比较小的 内存分配与回收策略从本质上来说，对象的分配都是分配在堆上的，但是随着技术的发展，即时编译产生的有些对象也会被分配到栈上。基于经典分代理论，新生对象一般都被分配到新生代，少数情况下被直接分配到老年代（比如触发了老年代内存担保） 对象在内存中如何分配创建的对象优先分配在Eden区域，当Eden区域快要满不足以分配新的对象时会发生Minor GC，此时会触发内存分配担保策略，根据判断结果判断如何进行垃圾收集，这时候会先去判断老年代中的最大连续空间大小是否大于新生代中的对象内存使用总和，如果大于则这次内存回收是安全的，进行Minor GC；如果不大于，这时候就要查看是否允许担保失败，如果允许，则查看老年代最大连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于则进行Minor GC，如果不大于或者本身就不允许担保失败则直接进行Full GC。也有部分对象会被直接分配到老年代，比如如果使用了-XX：PretenureSizeThreshold参数，那么创建的对象大小如果大于参数规定的值，这个时候就会被直接分配进入老年代。所以在创建对象的过程中我们应该严格注意不要创建大对象，尤其是“朝生夕死”的大对象，他们的对象复制以及空间占用对JVM来说都是一个不小的负担。长期存活的对象会从新生代进入老年代。Eden区域中的对象都是新创建出来的对象，当经过依次Minor GC之后如果没有被销毁，他就会进行Survivor区域，此时对象头中的年龄计数器就会+1，此后每经过依次垃圾收集，对象的年龄就会加1，到达一定的年龄后，对象就会被转移进入老年代。年龄阈值可以功过-XX：MaxTenuringThreshold设置。然后也有一种情况是对象的年龄没有到达阈值就被转移到了老年代，那就是在Survivor空间中的同龄对象的空间占用超过了Survivor空间的一半，此时会将这些对象统一转移到老年代中。HotSpot虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况 垃圾的回收时机是什么综上，当Eden区不足以分配新的对象时会触发Minor GC，当堆内存不足或者触发了内存担保并发现可能无法担保成功时会触发Full GC。 一些故障处理工具Java程序经常会因为一些编码错误或者内存问题发生程序崩溃，其中部分情况下可能都是因为堆中内存空间发生了异常，接下来对一些工具进行总结，在异常的场景下希望能够挑选出来合适的工具解决问题 jps -lv:可以查看当前虚拟机中跑的java进程，并能够看到具体的启动命令以及启动时候指定的参数 jinfo: jps -lv能够看到进程启动时候指定的参数，但是没法看到默认的参数，这个时候就可以使用jinfo命令来看默认的参数是什么，比如jinfo -flag CMSInitiatingOccupancyFraction jstat: 监视虚拟机各种运行状态信息，比如-gc参数监视Java堆状况、-gcutil显示Java堆各个区域空间占用百分比、-class参数监视类加载、卸载数量、总空间以及类装载所耗费的时间 jmap:生成堆转储文件，他有几个参数: -dump，生成堆转储文件、-heap，显示堆详细信息，如使用哪种回收器，参数配置，分代状况等、-histo，显示堆中对象统计信息，包括类，实例数量等。一般在JVM参数设定+HeapDumpOnOutOfMemoryError，效果就和-dump命令相似 jstack:生成虚拟机当前时刻的线程快照。 jhat:可以配合jmap命令查看生成的堆存储快照，不过一般没人用，推荐使用VisualVM和Jprofiler等工具","link":"/2025/04/30/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-md/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"AI","slug":"AI","link":"/tags/AI/"}],"categories":[],"pages":[]}